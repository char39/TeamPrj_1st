

◆ intro ◆
    안녕하세요, 저희는 Angry Bird Space 프로젝트를 진행한 [박성순 유안나]입니다.
    오늘 발표에서는 Angry Bird Space를 구현하면서 사용된 기술적 요소들을 중심으로 소개하려고 합니다.
    저희 팀이 이 프로젝트에서 어떤 방식으로 게임의 물리적 요소와 캐릭터 움직임을 구현했는지, 그리고 그 과정에서 얻은 기술적 경험을 차례로 설명드리겠습니다.
    프로젝트 발표를 시작하겠습니다.
    ;==>

◆ 목차 ◆
    ◆ [프로젝트 개요] ◆
    먼저 이 프로젝트의 목표와 선택한 이유, 개발 기간을 간단히 설명드리고
    ◆ [개발 과정] ◆
    개발 과정에서는 저희 팀이 게임을 만들기 위해 사용한 엔진 및 기여도에 대해 설명하겠습니다.
    ◆ [주요 기능] ◆
    세 번째로 이번 프로젝트의 핵심 기능을 소개할 예정입니다.
    여기서는 기능에 대한 설명과 함께, 구현 과정에서 겪었던 문제들과 이를 해결한 과정에 대해 설명하겠습니다.
    ◆ [마치며] ◆
    마지막으로 이번 프로젝트를 통해 얻은 성과와 교훈을 간단히 정리하며 발표를 마치겠습니다.
    ;==>

◆ 프로젝트 개요 ◆
    저희는 Angry Bird Space를 모티브로 프로젝트를 진행했습니다.
    이 게임은 행성의 중력을 이용한 독특한 게임 플레이 요소를 가지고 있으며 다양한 레벨로 구성되어 있어서 선택하게 되었습니다.
    ;==>
    이 게임은 우주를 배경으로 한 액션 퍼즐 게임으로, 플레이어가 새를 날려 돼지를 터뜨리는 기본적인 게임 플레이 방식을 가지고 있습니다.
    ;==>
    9월 13일부터 10월 25일까지 약 한 달간 진행되었습니다.
    ;==>

◆ 개발과정 ◆
    ◆ [사용한 엔진과 도구] ◆
    게임 개발에 사용한 엔진은 Unity 엔진이며, 개발 도구로는 VSCode를 사용했습니다.
    ;==>

    ◆ [각 팀원의 역할 및 기여도] ◆
    각 팀원이 맡은 역할과 그에 따른 기여도입니다.
    (유안나)는 게임의 전반적인 기획과 레벨 디자인을 맡았고, 각 레벨에 맞는 물리적 환경을 설정했습니다.
    또한, 게임의 효과음 처리와 UI/UX 부분을 담당하며, 게임의 사용자 경험을 개선하는 데 중요한 역할을 했습니다.
    (박성순)은 프로젝트에서 게임의 물리 시스템, 즉 중력장과 관련된 시스템들을 구현하고, 게임의 핵심 로직을 다루는 데 중요한 역할을 했습니다.
    이 외에도, 게임의 디버깅과 테스트를 통해 버그를 수정하고, 전반적인 게임의 완성도를 높이는 데 기여했습니다.
    ;==>
    ◆ [협업과정] ◆
        ◆ [기획 단계] ◆
        먼저 주제를 선정해 프로젝트의 큰 틀을 잡고, 각 팀원이 맡을 역할을 분배했습니다.
        ;==>
        역할과 작업을 분담하여 각자 맡은 부분을 책임감 있게 수행 했기에 개발 초기에 방향성을 확립할 수 있었습니다.
        ;==>

        ◆ [개발 단계] ◆
        원활한 코드 관리를 위해 Git을 사용했습니다.
        Git이란 버전 관리 시스템으로, 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일을 관리할 수 있게 도와줍니다.
        각 맡은 작업별 분기를 생성하여 개발을 진행한 뒤, 검토 후 통합하는 방식으로 작업을 진행했습니다.
        Git을 활용한 분기 관리 덕분에 각자의 작업이 서로 독립적으로 진행될 수 있었습니다.
        '실시간설명'
        ;==> 

        ◆ [통합 및 테스트] ◆
        마지막으로 각자 맡은 부분을 통합하고, 전체적인 게임 흐름과 기능이 잘 작동하는지 테스트하며, 오류나 버그를 수정했습니다.
        ;==>
        이렇게 기획부터 개발, 통합까지의 과정을 체계적으로 진행하며 성공적으로 프로젝트를 마무리할 수 있었습니다.
        ;==>
        
◆ 주요 기능 ◆
	◆ [기능 개요] ◆
    이 게임의 주요 기능을 크게 시스템 관리, 게임플레이와 기능 구현으로 나누었습니다.
    시스템 관리는 총 네 가지로 나뉘며, 각각의 기능들은 게임의 전반적인 흐름을 관리합니다.
    게임 플레이와 기능 구현은 다섯 가지로 나누었으며, 각 기능들은 게임의 핵심적인 부분입니다.
    ;==>
    먼저 관리 클래스는 게임의 전반적인 제어를 담당하며, 레벨 데이터 관리는 게임의 모든 레벨 데이터를 관리합니다. 
    ;==>
    또한 개발 편의를 위해 씬의 이름을 상수로 만들어 관리하는 클래스를 만들었습니다.
    게임에 사용되는 자원을 미리 불러와 게임 실행 중에 필요한 이미지를 즉각적으로 불러올 수 있도록 했습니다.
    ;==>
    더 나은 사용자 경험을 위해, 카메라 움직임을 부드럽게 구현하였고,
    전체적인 충돌 시스템을 담당하는 부분을 구현했습니다.
    또한 핵심 기능 중 하나인 발사대와 새를 구현했습니다.
    ;==>
    그리고 제일 중요한 기능인 중력장을 구현했습니다.
    마지막으로 중력장과 행성의 반지름을 설정하고, 변경 사항이 있을 시 실시간으로 적용되도록 구현했습니다.
    ;==>

    ◆ [기능별 설명] ◆
        ◆ [관리 클래스] ◆
        관리 클래스 중 하나인 GameManage 클래스는 나머지 모든 관리 클래스를 총괄하며, 이 게임에서 단 하나만 존재합니다.
        각각 UI, 레벨 데이터, 씬, 사운드와 관련된 모든 것을 총괄하며, 이 관리 클래스가 존재하는 씬은 절대 언로드 되지 않습니다.
        ;==>
        예시로 LevelManage에서 점수를 관리하는 메서드인 AddScore을 호출하면, 후술할 레벨 데이터 리스트에 있는 해당 Room의 점수를 추가하며, UI에도 점수를 업데이트합니다.
        ;==>
        게임을 플레이하던 중 재시작을 할 경우, SceneManage의 LoadLevel을 호출하여 임시 데이터값 초기화를 진행하고, 현재 씬을 다시 로드하게 됩니다.
        ;==>

        ◆ [레벨데이터] ◆
        각각의 레벨 데이터를 관리하기 위해, LevelData 클래스를 만들고, Dictionary를 이용해 레벨 데이터들을 선언했습니다.
        생성자를 통해 레벨 데이터를 초기화했으며, 추가하거나 삭제할 수 있도록 구현했습니다.
        ;==>
        또한, LevelRoomSize는 효율과 편의를 위해 클래스를 분리하여 구현했습니다.
        ;==>
        실제로 레벨 데이터를 사용하는 예시로, 앞서 설명한 LevelManage의 다른 메서드입니다.
        각각 해당 Room의 점수를 설정하고, 점수를 반환하는 메서드입니다.
        아래는 클리어 조건을 만족했을 때 UI를 업데이트하는 메서드의 일부로, 해당 Room의 클리어 조건을 저장합니다.
        ;==>

        ◆ [씬 관리] ◆
        앞서 말했듯이, 개발 편의를 위해 씬의 이름을 상수로 만들어 관리하는 클래스를 만들었습니다.
        이 값은 절대 변경되지 않고, 인스턴스를 여러 개 생성할 필요가 없기 때문에 정적 클래스로 구현했습니다.
        ;==>
        또한, 현재 씬의 이름을 상수로 반환하기 위한 메서드도 구현했습니다.
        물론 존재하지 않는 값이 들어올 경우 -1을 반환하여 예외 처리를 하였습니다.
        ;==>
        다음은 SceneManage에서 구현된 메서드 중 하나로, 씬을 로드하고 활성화하는 메서드입니다.
        앞서 말한 상수를 이용해 비동기로 씬을 로드하며, 씬이 로드되면 해당 씬을 활성화하는 이벤트를 호출합니다.
        아래는 씬을 언로드하는 메서드와, 현재 활성화된 씬의 상수값을 반환하는 메서드입니다.
        ;==>

        ◆ [리소스 관리] ◆
        보다 효율적인 자원 관리를 위해 정적 클래스를 만들어, 게임에 사용되는 자원을 미리 불러와 게임 실행 중에 필요한 자원을 즉시 불러오도록 했습니다.
        ;==>
        정적 클래스로 선언하였기에 동적 할당이 불가하고, 게임 시작 시 단 한 번 실행되어 종료될 때까지 메모리에 존재합니다.
        ;==>

        ◆ [카메라 움직임] ◆
        카메라 움직임은 카메라가 새를 따라다니는 기능과 마우스로 카메라를 좌우로 이동시키는 기능으로 분리하여 구현했습니다.
        카메라가 빨간 새를 따라가는 모습이며,
        마우스로 카메라를 좌우로 이동시키는 장면입니다.
        ;==>

        ◆ [충돌감지] ◆
        중력 적용 유무와 관계없이 충돌 감지만을 담당하는 기본 클래스인 ColliderDetection을 만들었습니다.
        대표적으로 Blocks 클래스가 이를 상속받아 충돌을 처리하고, 새로운 로직을 추가로 정의합니다.
        그리고 Blocks 클래스를 상속받은 자식 클래스에서 필요한 값들을 할당합니다.
        ;==>    // video size big & Auto play
        '영상 실행 중 설명'
        가속 없이 충돌 시 블록이 절반 정도 피해를 입은 장면입니다.
        ;==>
        이번엔 가속을 주어 충돌 시 블록이 사라지는 모습을 확인해보겠습니다.
        ;==>    // video size big & Auto play
        '영상 종료 후 다음 슬라이드 진행'
        ;==>
        스크립트를 보도록 할게염 ^_________^
        ;==>
        가장 기본이 되는 클래스인 ColliderDetection에서는 오직 충돌만을 감지하며 충격량을 계산하고, 충돌 판정을 내립니다.
        그리고 대표적으로 이를 상속받는 Blocks 클래스에서 상태를 관리하는 코드를 추가하여, 각 상태에 따라 다르게 처리합니다.
        ;==>
        충돌 판정을 담당하는 메서드를 재정의하여 각 블록의 상태에 따라 다르게 처리합니다.
        ;==>
        ;==>
        실제로 적용된 돌블럭과 나무블럭 클래스입니다.
        이 클래스들은 Blocks 클래스를 상속받으며, 이미지와 점수를 설정하고, 충돌 판정을 위한 충격량을 설정합니다.
        ;==>
        
        ◆ [발사대 및 새] ◆
        3종류의 새를 구현했습니다.
        ;==> red bird video 나옴
        Bird 스크립트 입니다. 중력 관련 컴포넌트를 가져오고, Update()에서 매 프레임마다 속도와 속력을 갱신합니다.
        모든 새들은 Bird 클래스를 상속받으며, 새의 종류에 따라 질량을 각각 다르게 설정합니다.
        현재 보이는 영상은 빨간 새의 플레이 장면입니다.
        ;==>  yellow bird
        yellow bird도 bird 클래스를 상속받으며 마우스를 누른 지점을 향해 날아갑니다.
        오브젝트의 회전 각도를 기준으로 스프라이트의 가로 및 세로 방향을 설정합니다.
        ;==> blue bird
        Blue Bird는 마우스를 클릭했을 때 날아가는 새를 중심으로 상하 15도씩 차이를 두고 세 마리로 분산되어 날아갑니다.
        Blue Burd 또한 Bird 클래스를 상속받습니다.
        ;==> slingshot 나옴
        슬링샷은 마우스가 새 위에 올라갔는지, 클릭되었는지, 당겨졌는지를 확인합니다.
        상호작용이 없는 객체인 PreBird 위에 마우스가 올라갔고, 클릭되었으며, 당겨졌다면, 마우스를 떼었을 때 PreBird를 삭제하고 Bird 객체를 생성하여 발사합니다.
        ;==>
        
        ◆ [중력장] ◆

        ◆ [행성 반지름 설정] ◆
        마지막으로, 중력장의 크기와 힘, 행성의 크기와 충돌 범위를 설정하기 위해 두 클래스로 나누어 구현했습니다.
        인스펙터에서 이 값들을 설정하면, 개발 편의를 위해 해당 값이 컴포넌트와 씬에 실시간으로 갱신되게 했습니다.
        ;==>
        이 클래스는 행성의 크기와 충돌 범위를 담당하는 클래스를 참조하여, 이미지와 콜라이더를 실시간으로 적용합니다.
        ;==>
        이 클래스는 중력장의 크기와 힘을 설정할 수 있는 클래스를 참조하여, 중력장의 크기를 실시간으로 적용합니다.
        두 클래스가 존재하는 이유는, 하나의 수치를 변경할 때마다 그 수치에 종속된 값들을 일일이 수정하는 번거로움을 줄이기 위해 구현되었습니다.
        또한 Editor 폴더에 위치하며, Unity Editor에서만 실행되어 런타임(게임 실행) 중에는 실행되지 않습니다.
        ;==>
