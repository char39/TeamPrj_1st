◆ intro ◆
    안녕하세요, 저희는 Angry Bird Space 프로젝트를 진행한 [박성순 유안나]입니다.
    오늘 발표에서는 Angry Bird Space를 구현하면서 사용된 기술적 요소들을 중심으로 소개하려고 합니다.
    저희 팀이 이 프로젝트에서 어떤 방식으로 게임의 물리적 요소와 캐릭터 움직임을 구현했는지, 그리고 그 과정에서 얻은 기술적 경험을 차례로 설명드리겠습니다.
    프로젝트 발표를 시작하겠습니다.
    ;==>

◆ 목차 ◆
    ◆ [프로젝트 개요] ◆
    먼저 이 프로젝트의 목표와 선택한 이유, 개발 기간을 간단히 설명드리고
    ◆ [개발 과정] ◆
    개발 과정에서는 저희 팀이 게임을 만들기 위해 사용한 엔진 및 기여도에 대해 설명하겠습니다.
    ◆ [주요 기능] ◆
    세 번째로 이번 프로젝트의 핵심 기능을 소개할 예정입니다.
    여기서는 기능에 대한 설명과 함께, 구현 과정에서 겪었던 문제들과 이를 해결한 과정에 대해 설명하겠습니다.
    ◆ [마치며] ◆
    마지막으로 이번 프로젝트를 통해 얻은 성과와 교훈을 간단히 정리하며 발표를 마치겠습니다.
    ;==>

◆ 프로젝트 개요 ◆
    저희는 Angry Bird Space를 모티브로 프로젝트를 진행했습니다.
    이 게임은 행성의 중력을 이용한 독특한 게임 플레이 요소를 가지고 있으며 다양한 레벨로 구성되어 있어서 선택하게 되었습니다.
    ;==>
    이 게임은 우주를 배경으로 한 액션 퍼즐 게임으로, 플레이어가 새를 날려 돼지를 터뜨리는 기본적인 게임 플레이 방식을 가지고 있습니다.
    ;==>
    9월 13일부터 10월 25일까지 약 한 달간 진행되었습니다.
    ;==>

◆ 개발과정 ◆
    ◆ [사용한 엔진과 도구] ◆
    게임 개발에 사용한 엔진은 Unity 엔진이며, 개발 도구로는 VSCode를 사용했습니다.
    ;==>

    ◆ [각 팀원의 역할 및 기여도] ◆
    각 팀원이 맡은 역할과 그에 따른 기여도입니다.
    (유안나)는 게임의 전반적인 기획과 레벨 디자인을 맡았고, 각 레벨에 맞는 물리적 환경을 설정했습니다.
    또한, 게임의 효과음 처리와 UI/UX 부분을 담당하며, 게임의 사용자 경험을 개선하는 데 중요한 역할을 했습니다.
    (박성순)은 프로젝트에서 게임의 물리 시스템, 즉 중력장과 관련된 시스템들을 구현하고, 게임의 핵심 로직을 다루는 데 중요한 역할을 했습니다.
    이 외에도, 게임의 디버깅과 테스트를 통해 버그를 수정하고, 전반적인 게임의 완성도를 높이는 데 기여했습니다.
    ;==>
    ◆ [협업과정] ◆
        ◆ [기획 단계] ◆
        먼저 주제를 선정해 프로젝트의 큰 틀을 잡고, 각 팀원이 맡을 역할을 분배했습니다.
        ;==>
        역할과 작업을 분담하여 각자 맡은 부분을 책임감 있게 수행 했기에 개발 초기에 방향성을 확립할 수 있었습니다.
        ;==>

        ◆ [개발 단계] ◆
        원활한 코드 관리를 위해 Git을 사용했습니다.
        Git이란 버전 관리 시스템으로, 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일을 관리할 수 있게 도와줍니다.
        각 맡은 작업별 분기를 생성하여 개발을 진행한 뒤, 검토 후 통합하는 방식으로 작업을 진행했습니다.
        Git을 활용한 분기 관리 덕분에 각자의 작업이 서로 독립적으로 진행될 수 있었습니다.
        '실시간설명'
        ;==> 

        ◆ [통합 및 테스트] ◆
        마지막으로 각자 맡은 부분을 통합하고, 전체적인 게임 흐름과 기능이 잘 작동하는지 테스트하며, 오류나 버그를 수정했습니다.
        ;==>
        이렇게 기획부터 개발, 통합까지의 과정을 체계적으로 진행하며 성공적으로 프로젝트를 마무리할 수 있었습니다.
        ;==>
        
◆ 주요 기능 ◆
	◆ [기능 개요] ◆
    이 게임의 주요 기능을 크게 시스템 관리, 게임플레이와 기능 구현으로 나누었습니다.
    시스템 관리는 총 네 가지로 나뉘며, 각각의 기능들은 게임의 전반적인 흐름을 관리합니다.
    게임 플레이와 기능 구현은 다섯 가지로 나누었으며, 각 기능들은 게임의 핵심적인 부분입니다.
    ;==>
    먼저 관리 클래스는 게임의 전반적인 제어를 담당하며, 레벨 데이터 관리는 게임의 모든 레벨 데이터를 관리합니다. 
    ;==>
    또한 개발 편의를 위해 씬의 이름을 상수로 만들어 관리하는 클래스를 만들었습니다.
    게임에 사용되는 자원을 미리 불러와 게임 실행 중에 필요한 이미지를 즉각적으로 불러올 수 있도록 했습니다.
    ;==>
    더 나은 사용자 경험을 위해, 카메라 움직임을 부드럽게 구현하였고,
    전체적인 충돌 시스템을 담당하는 부분을 구현했습니다.
    또한 핵심 기능 중 하나인 발사대와 새를 구현했습니다.
    ;==>
    그리고 제일 중요한 기능인 중력장을 구현했습니다.
    마지막으로 중력장과 행성의 반지름을 설정하고, 변경 사항이 있을 시 실시간으로 적용되도록 구현했습니다.
    ;==>

    ◆ [기능별 설명] ◆
        ◆ [관리 클래스] ◆
        관리 클래스 중 하나인 GameManage 클래스는 나머지 모든 관리 클래스를 총괄하며, 이 게임에서 단 하나만 존재합니다.
        각각 UI, 레벨 데이터, 씬, 사운드와 관련된 모든 것을 총괄하며, 이 관리 클래스가 존재하는 씬은 절대 언로드 되지 않습니다.
        ;==>
        예시로 LevelManage에서 점수를 관리하는 메서드인 AddScore을 호출하면, 후술할 레벨 데이터 리스트에 있는 해당 Room의 점수를 추가하며, UI에도 점수를 업데이트합니다.
        ;==>
        게임을 플레이하던 중 재시작을 할 경우, SceneManage의 LoadLevel을 호출하여 임시 데이터값 초기화를 진행하고, 현재 씬을 다시 로드하게 됩니다.
        ;==>

        ◆ [레벨데이터] ◆
        각각의 레벨 데이터를 관리하기 위해, LevelData 클래스를 만들고, Dictionary를 이용해 레벨 데이터들을 선언했습니다.
        생성자를 통해 레벨 데이터를 초기화했으며, 추가하거나 삭제할 수 있도록 구현했습니다.
        ;==>
        또한, LevelRoomSize는 효율과 편의를 위해 클래스를 분리하여 구현했습니다.
        ;==>
        실제로 레벨 데이터를 사용하는 예시로, 앞서 설명한 LevelManage의 다른 메서드입니다.
        각각 해당 Room의 점수를 설정하고, 점수를 반환하는 메서드입니다.
        아래는 클리어 조건을 만족했을 때 UI를 업데이트하는 메서드의 일부로, 해당 Room의 클리어 조건을 저장합니다.
        ;==>

        ◆ [씬 관리] ◆
        앞서 말했듯이, 개발 편의를 위해 씬의 이름을 상수로 만들어 관리하는 클래스를 만들었습니다.
        이 값은 절대 변경되지 않고, 인스턴스를 여러 개 생성할 필요가 없기 때문에 정적 클래스로 구현했습니다.
        ;==>
        또한, 현재 씬의 이름을 상수로 반환하기 위한 메서드도 구현했습니다.
        물론 존재하지 않는 값이 들어올 경우 -1을 반환하여 예외 처리를 하였습니다.
        ;==>
        다음은 SceneManage에서 구현된 메서드 중 하나로, 씬을 로드하고 활성화하는 메서드입니다.
        앞서 말한 상수를 이용해 비동기로 씬을 로드하며, 씬이 로드되면 해당 씬을 활성화하는 이벤트를 호출합니다.
        아래는 씬을 언로드하는 메서드와, 현재 활성화된 씬의 상수값을 반환하는 메서드입니다.
        ;==>

        ◆ [리소스 관리] ◆
        보다 효율적인 자원 관리를 위해 정적 클래스를 만들어, 게임에 사용되는 자원을 미리 불러와 게임 실행 중에 필요한 자원을 즉시 불러오도록 했습니다.
        ;==>
        정적 클래스로 선언하였기에 동적 할당이 불가하고, 게임 시작 시 단 한 번 실행되어 종료될 때까지 메모리에 존재합니다.
        ;==>

        ◆ [카메라 움직임] ◆
        카메라 움직임은 카메라가 새를 따라다니는 기능과 마우스로 카메라를 좌우로 이동시키는 기능으로 분리하여 구현했습니다.
        카메라가 빨간 새를 따라가는 모습이며,
        마우스로 카메라를 좌우로 이동시키는 장면입니다.
        ;==>

        ◆ [충돌감지] ◆
        중력 적용 유무와 관계없이 충돌 감지만을 담당하는 기본 클래스인 ColliderDetection을 만들었습니다.
        대표적으로 Blocks 클래스가 이를 상속받아 충돌을 처리하고, 새로운 로직을 추가로 정의합니다.
        그리고 Blocks 클래스를 상속받은 자식 클래스에서 필요한 값들을 할당합니다.
        ;==>    // video size big & Auto play
        '영상 실행 중 설명'
        가속 없이 충돌 시 블록이 절반 정도 피해를 입은 장면입니다.
        ;==>
        이번엔 가속을 주어 충돌 시 블록이 사라지는 모습을 확인해보겠습니다.
        ;==>    // video size big & Auto play
        '영상 종료 후 다음 슬라이드 진행'
        ;==>
        스크립트를 보도록 할게염 ^_____^
        ;==>
        가장 기본이 되는 클래스인 ColliderDetection에서는 오직 충돌만을 감지하며 충격량을 계산하고, 충돌 판정을 내립니다.
        그리고 대표적으로 이를 상속받는 Blocks 클래스에서 상태를 관리하는 코드를 추가하여, 각 상태에 따라 다르게 처리합니다.
        ;==>
        블록의 상태에 따라 다르게 처리하기 위해 충돌 판정을 담당하는 메서드를 재정의했습니다.
        ;==>
        ;==>
        실제로 적용된 돌블럭과 나무블럭 클래스입니다.
        이 클래스들은 Blocks 클래스를 상속받으며, 이미지와 점수를 설정하고, 충돌 판정을 위한 충격량을 설정합니다.
        ;==>
        
        ◆ [발사대 및 새] ◆
        총 3종류의 새를 구현했습니다. 빨간 새, 노란 새, 파란 새입니다.
        ;==>
        모든 새들은 Bird 클래스를 상속받으며, 새의 종류에 따라 질량과 특별한 능력을 각각 다르게 설정합니다.
        빨간 새의 경우, 특별히 능력은 없으며 질량만 6으로 설정했습니다.
        ;==>
        노란 새는 발사된 후, 마우스를 누른 지점을 향해 날아가며, 현재 나아가는 방향을 기준으로 이미지 반전 여부를 설정합니다.
        ;==>
        파란 새는 마우스를 클릭했을 때, 상하 15도씩 차이를 두고 세 마리로 분산되어 날아갑니다.
        모든 새의 능력은 충돌하기 전에 사용 가능하며, 충돌 판정 후에는 사용할 수 없습니다.
        ;==>
        발사대에 새가 있는 경우, 마우스가 새 위에 올라갔는지, 클릭되었는지, 당겨졌는지를 확인합니다.
        각각 조건에 따라 새를 당기고, 발사하는 기능을 구현했습니다.
        ;==>

        ◆ [중력장] ◆
        제일 중요한 기능인 중력장입니다.
        가장 먼저 기초가 되는 인터페이스를 만들고, 추후 다른 중력장도 만들 수 있도록 인터페이스를 상속받아 추상 클래스를 만들었습니다.
        '하지만 원형 중력장만 있다는 슬픈 사실'
        ;==>
        원형 중력장입니다.
        GravityTarget 컴포넌트를 가진 오브젝트를 계속 찾고, 범위 내에 있을 때만 중력을 적용합니다.
        ;==>
        방금 설명한 중력을 받기 위해 필요한 컴포넌트입니다.
        해당 클래스는 Rigidbody2D 컴포넌트를 필수로 요구하며, 중력을 받을 오브젝트에 추가해야 합니다.
        또한 아래에 있는 클래스는 마찰력을 적용하기 위해 필요한 컴포넌트입니다.
        ;==>

        ◆ [행성 반지름 설정] ◆
        마지막으로, 중력장의 크기와 힘, 행성의 크기와 충돌 범위를 설정하기 위해 두 클래스로 나누어 구현했습니다.
        인스펙터에서 이 값들을 설정하면, 개발 편의를 위해 해당 값이 컴포넌트와 씬에 실시간으로 갱신되게 했습니다.
        ;==>
        이 클래스는 행성의 크기와 충돌 범위를 담당하는 클래스를 참조하여, 이미지와 콜라이더를 실시간으로 적용합니다.
        ;==>
        이 클래스는 중력장의 크기와 힘을 설정할 수 있는 클래스를 참조하여, 중력장의 크기를 실시간으로 적용합니다.
        두 클래스가 존재하는 이유는, 하나의 수치를 변경할 때마다 그 수치에 종속된 값들을 일일이 수정하는 번거로움을 줄이기 위해 구현되었습니다.
        또한 Editor 폴더에 위치하며, Unity Editor에서만 실행되어 런타임(게임 실행) 중에는 실행되지 않습니다.
        ;==>

    ◆ 도전 과정 ◆
        주요 기능을 개발하는 과정에서 크게 두 가지 도전이 있었습니다.
        중력 로직과 관리 클래스에서 각각 문제점이 있었고, 이를 어떻게 해결했는지 설명하겠습니다.
        ;==>

        ◆ 중력 로직 ◆
        기존 코드는 행성 클래스와 중력 클래스가 서로 연결되어 중력을 제공하는 방식이었습니다.
        ;==>
        그리고 여러 클래스에서 중력을 받는 코드가 중복되어 있었으며, 중력을 받는 객체를 찾는 과정에서 오류가 발생했었습니다.
        ;==>
        이 문제를 해결하기 위해, 중력을 제공하는 클래스는 모든 중력 관련 계산을 담당하게 되었으며, 중력을 받는 객체를 찾는 로직을 변경했습니다.
        '기존 코드는 콜라이더 충돌 여부로 판단했지만, 중력을 받는 클래스를 전부 찾아서 중력을 적용하도록 변경함'
        ;==>
        또한, 중력을 받는 코드 역시 하나의 클래스로 통합하여 중복을 제거했습니다.
        이전에는 중력을 받는 코드가 각 클래스마다 다르게 존재했으나, 이를 하나의 클래스로 통합하여 효율적으로 관리할 수 있게 되었습니다.
        ;==>

        ◆ 관리 클래스 ◆
        관리 클래스 또한 초기에는 GameManage 하나의 클래스에 모든 기능을 담당하도록 설계되었습니다.
        하지만 점점 기능이 추가되면서 너무 복잡해지고, 유지보수와 확장이 어려워졌습니다.
        ;==>
        이를 해결하기 위해, GameManage 클래스에 있는 기능을 분리하여, 각 기능을 담당하는 클래스를 만들었습니다.
        ;==>
        GameManage 클래스는 이제 관리 클래스들을 총괄하며, 각각의 클래스가 관리 기능을 담당하도록 설계함으로써, 유지보수와 확장성을 높일 수 있었습니다.
        ;==>

◆ 마치며 ◆
    [프로젝트에서 배운점 '이자 장점인']
    저희는 프로젝트를 진행하며 크게 3가지를 배웠습니다.
    ;==> importance of collaboration
    첫 번째로, 이번 프로젝트를 통해 협업의 진정한 가치를 깨달았습니다.
    팀원들과 함께 의견을 조율하고 문제를 해결하는 과정에서, 단순히 업무를 분담하는 것을 넘어 서로의 강점을 보완해 프로젝트를 함께 완성하며 책임감을 느끼고 성취감을 얻었습니다.
    ;==> development process
    그리고 게임 개발에 대한 이해도를 높이는 좋은 기회였습니다.
    캐릭터 움직임과 물리 계산 등 다양한 요소들을 직접 구현하며 개발 감각을 키울 수 있었고
    ;==> problem solving skills
    예상치 못한 문제들을 해결하는 과정에서 문제 해결 능력도 향상되었습니다.

    하지만 협업 과정에서 어려움도 있었습니다. 다양한 의견이 존재하다 보니 작은 갈등이 발생하기도 했지만, 서로를 존중하고 대화를 통해 해결하거나 적절히 조율했습니다.
    또한, 팀원이 2명이라 객관적인 평가가 부족했지만 다양한 시각으로 문제를 바라보려 노력했습니다.

    반면, 개인적으로 작업할 때는 자유로운 개발 환경에서 나만의 방식으로 코드를 작성할 수 있다는 장점이 있었습니다.
    하지만 동기 부여를 유지하고 일정을 관리하는 데 어려움을 느꼈으며, 전문적인 지식이 부족한 부분에서는 한계를 경험하기도 했습니다.

    결론적으로, 이번 프로젝트를 통해 협업의 중요성을 다시 한번 느끼고, 개인의 역량을 향상시킬 수 있는 소중한 경험을 얻었습니다.
    앞으로도 이러한 경험을 바탕으로 더욱 발전된 프로젝트를 만들어나가고 싶습니다.
    ;==>
    발표 마치겠습니다. 감사합니다땡큐 Thx-별.ㅋㅋㅋㅋ