

◆ intro ◆
    안녕하세요, 저희는 Angry Bird Space 프로젝트를 진행한 [박성순 유안나]입니다.
    오늘 발표에서는 Angry Bird Space를 구현하면서 사용된 기술적 요소들을 중심으로 소개하려고 합니다.
    저희 팀이 이 프로젝트에서 어떤 방식으로 게임의 물리적 요소와 캐릭터 움직임을 구현했는지, 그리고 그 과정에서 얻은 기술적 경험을 차례로 설명드리겠습니다.
    프로젝트 발표를 시작하겠습니다.
    ;==>

◆ 목차 ◆
    ◆ [프로젝트 개요] ◆
    먼저 이 프로젝트의 목표와 선택한 이유, 개발 기간을 간단히 설명드리고
    ◆ [개발 과정] ◆
    개발 과정에서는 저희 팀이 게임을 만들기 위해 사용한 엔진 및 기여도에 대해 설명하겠습니다.
    ◆ [주요 기능] ◆
    세 번째로 이번 프로젝트의 핵심 기능을 소개할 예정입니다.
    여기서는 기능에 대한 설명과 함께, 구현 과정에서 겪었던 문제들과 이를 해결한 과정에 대해 설명하겠습니다.
    ◆ [마치며] ◆
    마지막으로 이번 프로젝트를 통해 얻은 성과와 교훈을 간단히 정리하며 발표를 마치겠습니다.
    ;==>

◆ 프로젝트 개요 ◆
    저희는 Angry Bird Space를 모티브로 프로젝트를 진행했습니다.
    이 게임은 행성의 중력을 이용한 독특한 게임 플레이 요소를 가지고 있으며 다양한 레벨로 구성되어 있어서 선택하게 되었습니다.
    ;==>
    이 게임은 우주를 배경으로 한 액션 퍼즐 게임으로, 플레이어가 새를 날려 돼지를 터뜨리는 기본적인 게임 플레이 방식을 가지고 있습니다.
    ;==>
    개발 일정은 9월 13일부터 10월 25일까지 약 한 달간 진행되었습니다.
    ;==>

◆ 개발과정 ◆
    ◆ [사용한 엔진과 도구] ◆
    게임 개발에 사용한 엔진은 Unity 엔진이며, 개발 도구로는 VSCode를 사용했습니다.
    ;==>
    ◆ [각 팀원의 역할 및 기여도] ◆
    각 팀원이 맡은 역할과 그에 따른 기여도를 설명하겠습니다.
    (유안나)는 게임의 전반적인 기획과 레벨 디자인을 맡았고, 각 레벨에 맞는 물리적 환경을 설정했습니다.
    또한, 게임의 효과음 처리와 UI/UX 부분을 담당하며, 게임의 사용자 경험을 개선하는 데 중요한 역할을 했습니다.
    (박성순)은 프로젝트에서 게임의 물리 시스템, 즉 중력장과 관련된 시스템들을 구현하고, 게임의 핵심 로직을 다루는 데 중요한 역할을 했습니다.
    이 외에도, 게임의 디버깅과 테스트를 통해 버그를 수정하고, 전반적인 게임의 완성도를 높이는 데 기여했습니다.
    ;==>
    ◆ [협업과정] ◆
        ◆ [기획 단계] ◆
        먼저 주제를 선정해 프로젝트의 큰 틀을 잡고, 각 팀원이 맡을 역할을 분배했습니다.
        ;==>
        역할과 작업을 분담하여 각자 맡은 부분을 책임감 있게 수행 했기에 개발 초기에 방향성을 확립할 수 있었습니다.
        ;==>
        ◆ [개발 단계] ◆
        원활한 코드 관리를 위해 Git을 사용했습니다.
        Git이란 버전 관리 시스템으로, 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일을 관리할 수 있게 도와줍니다.
        각 맡은 작업별 분기를 생성하여 개발을 진행한 뒤, 검토 후 통합하는 방식으로 작업을 진행했습니다.
        Git을 활용한 분기 관리 덕분에 각자의 작업이 서로 독립적으로 진행될 수 있었습니다.
        ;==> 
        ◆ [통합 및 테스트] ◆
        마지막으로 각자 맡은 부분을 통합하고, 전체적인 게임 흐름과 기능이 잘 작동하는지 테스트하며, 오류나 버그를 수정했습니다.
        ;==>
        이렇게 기획부터 개발, 통합까지의 과정을 체계적으로 진행하며 성공적으로 프로젝트를 마무리할 수 있었습니다.
        ;==>
        
◆ 주요 기능 ◆
	◆ [기능 개요] ◆
    이 게임의 주요 기능을 크게 시스템 관리, 게임플레이와 기능 구현으로 나누었습니다.
    시스템 관리는 총 네 가지로 나뉘며, 각각의 기능들은 게임의 전반적인 흐름을 관리합니다.
    게임 플레이와 기능 구현은 다섯 가지로 나누었으며, 각 기능들은 게임의 핵심적인 부분입니다.
    ;==>

    먼저 관리 클래스는 게임의 전반적인 제어를 담당하며, 레벨 데이터 관리는 게임의 모든 레벨 데이터를 관리합니다. 
    ;==>

    또한 개발 편의를 위해 씬의 이름을 상수로 만들어 관리하는 클래스를 만들었습니다.
    게임에 사용되는 자원을 미리 불러와 게임 실행 중에 필요한 이미지를 즉각적으로 불러올 수 있도록 했습니다.
    ;==>
    
    더 나은 사용자 경험을 위해, 카메라 움직임을 부드럽게 구현하였고,
    전체적인 충돌 시스템을 담당하는 부분을 구현했습니다.
    또한 핵심 기능 중 하나인 발사대와 새를 구현했습니다.
    ;==>

    그리고 제일 중요한 기능인 중력장을 담당하는 클래스입니다.
    마지막으로 중력장을 구현했으니 중력장의 크기와 힘을 설정할 수 있는 클래스를 만들었습니다.
    ;==>

    ◆ [기능별 설명] ◆
        ◆ [관리 클래스] ◆
        관리 클래스 중 하나인 GameManage 클래스는 나머지 모든 관리 클래스를 총괄하며, 이 게임에서 단 하나만 존재합니다.
        각각 UI, 레벨 데이터, 씬, 사운드와 관련된 모든 것을 총괄하며, 이 관리 클래스가 존재하는 씬은 절대 언로드 되지 않습니다.
        ;==>

        예시로 LevelManage에서 점수를 관리하는 메서드인 AddScore을 호출하면, 후술할 레벨 데이터 리스트에 있는 해당 Room의 점수를 추가하며, UI에도 점수를 업데이트합니다.
        ;==>

        게임을 플레이하던 중 재시작을 할 경우, SceneManage의 LoadLevel을 호출하여 임시 데이터값 초기화를 진행하고, 현재 씬을 다시 로드하게 됩니다.
        ;==>

        ◆ [레벨데이터] ◆
        각각의 레벨 데이터를 관리하기 위해, LevelData 클래스를 만들고, Dictionary를 이용해 레벨 데이터들을 선언했습니다.
        생성자를 통해 레벨 데이터를 초기화했으며, 추가하거나 삭제할 수 있도록 구현했습니다.
        ;==>

        또한, LevelRoomSize는 효율과 편의를 위해 클래스를 분리하여 구현했습니다.
        ;==>

        실제로 레벨 데이터를 사용하는 예시로, 앞서 설명한 LevelManage의 다른 메서드입니다.
        각각 해당 Room의 점수를 설정하고, 점수를 반환하는 메서드입니다.

        아래는 클리어 조건을 만족했을 때 UI를 업데이트하는 메서드의 일부로, 해당 Room의 클리어 조건을 저장합니다.
        ;==>

        ◆ [씬 관리] ◆
        앞서 말했듯이, 개발 편의를 위해 씬의 이름을 상수로 만들어 관리하는 클래스를 만들었습니다.
        이 값은 절대 변경되지 않고, 인스턴스를 여러 개 생성할 필요가 없기 때문에 정적 클래스로 구현했습니다.
        ;==>

        또한, 현재 씬의 이름을 상수로 반환하기 위한 메서드도 구현했습니다.
        물론 존재하지 않는 값이 들어올 경우 -1을 반환하여 예외 처리를 하였습니다.
        ;==>

        ◆ [카메라 움직임] ◆
        카메라 움직임은 카메라가 새를 따라다니는 기능과 마우스로 카메라를 좌우로 이동시키는 기능으로 분리하여 구현했습니다.
        카메라가 빨간 새를 따라가는 모습이며,
        마우스로 카메라를 좌우로 이동시키는 장면입니다.
        ;==>

        ◆ [충돌감지] ◆
        ;==>    //video size big & Auto play
        하나의 돌을 선택하고 인스펙터 창에서 확인해보겠습니다. 현재 돌의 State는 기본값인 Block1로 설정되어 있으며 Require Force는 10입니다. 새와 충돌한 후 State가 Block3으로 변경되었으며 Require Force도 5로 줄어든 것을 확인할 수 있습니다.
        ;==>    //video size small
        ;==>    //video size big & Auto Play
        이번에는 Require Force만큼의 힘을 한 번에 받아 블록이 사라지는 모습을 확인해보겠습니다.
        이렇게 블록에 가해진 힘에 따라 블록의 상태가 변하고 Require Force도 함께 변경되도록 구현했습니다.
        ;==>    //only show class name
        스크립트를 보도록 할게염^___^
        ;==>    //full script
        
        충돌을 감지하는 가장 기본 클래스인 ColliderDetection을 만들어, 충돌하는 오브젝트들이 이를 상속하도록 했습니다.
        대표적으로 Blocks 클래스가 이를 상속받아 

        이 코드는 오브젝트의 충돌 처리를 담당하는 부분입니다.
        충돌을 감지하는 기본 클래스인 ColliderDetection을 만들어, 충돌하는 오브젝트들이 이를 상속하도록 했습니다.
        isTouched는 오브젝트가 충돌했을 때 true로 설정되며, canExplode는 requireForce보다 큰 힘이 가해졌을 때 true로 변경됩니다.
        Detection() 함수는 isTouched와 canExplode가 모두 true일 때 실행되는 메서드로, 점수를 추가하고 오브젝트를 삭제하는 역할을 합니다.

        다양한 블록들의 효율적인 충돌 처리를 위해 Block 클래스를 만들어 블록의 충돌을 감지하도록 했습니다.
        이 클래스는 ColliderDetection을 상속받습니다.
        열거형을 사용해 오브젝트의 상태를 관리하고, 각 상태에 따라 오브젝트의 행동을 다르게 처리합니다.
        
        ;==>    //Detection 함수 나옴
        Detection 함수는 오브젝트의 상태에 따라 점수를 추가하는 역할을 합니다.
        switch문을 사용하여 각 상태에 맞는 점수를 계산하고, AddScore() 함수를 통해 점수를 추가합니다.
        그 후, 오브젝트를 파괴합니다.
        ;==>    //class name
        Stone, Wood 등 다양한 블록들이 Block 클래스를 상속받아 충돌을 감지하도록 구현했습니다.
        ;==>    //full script
        각자 특성(필요한 힘, 점수, 스프라이트)을 설정하는 기능을 담당합니다.
        

